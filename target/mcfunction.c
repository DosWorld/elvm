
#include <ir/ir.h>
#include <target/util.h>
#include <stdlib.h>
#include <string.h>

#define SOA "scoreboard objectives add "
#define SPG "scoreboard players get "
#define SPS "scoreboard players set "
#define SPA "scoreboard players add "
#define SPR "scoreboard players remove "
#define SPO "scoreboard players operation "
#define DMS "data modify storage elvm:elvm "
#define DGS "data get storage elvm:elvm "
#define DRS "data remove storage elvm:elvm "
#define DMES "data merge storage elvm:elvm "
#define EIS "execute if score "
#define EUS "execute unless score "
#define E "execute "
#define SRST "store result storage elvm:elvm "
#define SRSC "store result score "
#define SFS "set from storage elvm:elvm "
#define F "function "

#define ELVM_PC "ELVM elvm_pc "
#define ELVM_MEM_ADDR "ELVM elvm_mem_addr "
#define ELVM_TMP "ELVM elvm_tmp "
#define ELVM_PARAM "ELVM elvm_param "

static const char* MCFUNCTION_REG_NAMES[7] = { "elvm_a", "elvm_b", "elvm_c", "elvm_d", "elvm_bp", "elvm_sp", "elvm_pc" };

static bool used_chr_function = 0;
static bool used_flush_function = 0;

static void mcf_char_to_string(char c, char* out) {
  if ((c >= 0 && c < 32) || c == 127)
    c = ' ';

  if (c == '"' || c == '\\') {
    out[0] = '\\';
    out[1] = c;
    out[2] = '\0';
  } else if (!(c & 0x80)) {
    out[0] = c;
    out[1] = '\0';
  } else {
    out[0] = (char)0xc0 | (char)(((unsigned)c & 0xff) >> 6);
    out[1] = (char)0x80 | (c & (char)0x3f);
    out[2] = '\0';
  }
}

static void mcf_static_read_mem_loc(int loc, char* res) {
  res[0] = 'm';
  res[1] = 'e';
  res[2] = 'm';
  for (int i = 0; i < 24; i++) {
    res[3 + 2 * i] = '.';
    res[4 + 2 * i] = (loc & (1 << (23 - i))) ? (char)'r' : (char)'l';
  }
  res[51] = '\0';
}

static void mcf_static_write_mem_loc(int loc, char* res) {
  res[0] = '{';
  res[1] = '"';
  res[2] = 'm';
  res[3] = 'e';
  res[4] = 'm';
  res[5] = '"';
  res[6] = ':';
  for (int i = 0; i < 24; i++) {
    res[7 + 5 * i] = '{';
    res[8 + 5 * i] = '"';
    res[9 + 5 * i] = (loc & (1 << (23 - i))) ? (char)'r' : (char)'l';
    res[10 + 5 * i] = '"';
    res[11 + 5 * i] = ':';
  }
  res[127] = '\0';
}

static void mcf_emit_function_header(const char *name) {
  emit_line("========= %s.mcfunction =========", name);
  emit_line("# Generated by ELVM");
}

static void mcf_emit_set_reg(const char *reg, Value *value) {
  if (value->type == REG)
    emit_line(SPO "ELVM %s = ELVM %s", reg, reg_names[value->reg]);
  else if (value->type == IMM)
    emit_line(SPS "ELVM %s %d", reg, value->imm);
  else
    error("invalid value");
}

static void mcf_emit_mem_table_store(Value *addr, Value *value) {
  if (addr->type == IMM) {
    char write_mem_loc[128];
    mcf_static_write_mem_loc(addr->imm, write_mem_loc);
    if (value->type == IMM) {
      emit_line(DMES "%s%d}}}}}}}}}}}}}}}}}}}}}}}}}", write_mem_loc, value->imm);
    } else {
      emit_line(DMES "%s0}}}}}}}}}}}}}}}}}}}}}}}}}", write_mem_loc);
      mcf_static_read_mem_loc(addr->imm, write_mem_loc);
      emit_line(E SRST "%s int 1 run " SPG "ELVM %s",
                write_mem_loc, reg_names[value->reg]);
    }
  } else {
    emit_line(DMS "mem_tmp set value [{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}]");
    mcf_emit_set_reg("elvm_mem_addr", addr);
    emit_line(EIS ELVM_MEM_ADDR "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.l");
    emit_line(EUS ELVM_MEM_ADDR "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.r");
    emit_line(EUS ELVM_MEM_ADDR "matches ..8388607 run " SPR ELVM_MEM_ADDR "8388608");
    for (int i = 1; i < 23; i++) {
      emit_line(EIS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].l", (1 << (23 - i)) - 1, i, i - 1);
      emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].r", (1 << (23 - i)) - 1, i, i - 1);
      emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " SPR ELVM_MEM_ADDR "%d", (1 << (23 - i)) - 1, 1 << (23 - i));
    }
    if (value->type == IMM) {
      emit_line(EIS ELVM_MEM_ADDR "matches 0 run " DMS "mem_tmp[22].l set value %d", value->imm);
      emit_line(EUS ELVM_MEM_ADDR "matches 0 run " DMS "mem_tmp[22].r set value %d", value->imm);
    } else {
      emit_line(EIS ELVM_MEM_ADDR "matches 0 " SRST "mem_tmp[22].l int 1 run " SPG "ELVM %s", reg_names[value->reg]);
      emit_line(EUS ELVM_MEM_ADDR "matches 0 " SRST "mem_tmp[22].r int 1 run " SPG "ELVM %s", reg_names[value->reg]);
    }
    mcf_emit_set_reg("elvm_mem_addr", addr);
    for (int i = 22; i >= 1; i--) {
      emit_line(SPO ELVM_MEM_ADDR "/= ELVM elvm_two");
      emit_line(SPO ELVM_TMP "= ELVM elvm_mem_addr");
      emit_line(SPO ELVM_TMP "%%= ELVM elvm_two");
      emit_line(EIS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].l " SFS "mem_tmp[%d]", i - 1, i);
      emit_line(EUS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].r " SFS "mem_tmp[%d]", i - 1, i);
    }
    emit_line(SPO ELVM_MEM_ADDR "/= ELVM elvm_two");
    emit_line(SPO ELVM_MEM_ADDR "%%= ELVM elvm_two");
    emit_line(EIS ELVM_MEM_ADDR "matches 0 run " DMS "mem.l " SFS "mem_tmp[0]");
    emit_line(EUS ELVM_MEM_ADDR "matches 0 run " DMS "mem.r " SFS "mem_tmp[0]");
  }
}

static void mcf_emit_mem_table_load(const char* dst_reg, Value* addr) {
  if (addr->type == IMM) {
    char read_mem_loc[52];
    mcf_static_read_mem_loc(addr->imm, read_mem_loc);
    emit_line(E SRSC "ELVM %s run " DGS "%s", dst_reg, read_mem_loc);
  } else {
    mcf_emit_set_reg("elvm_mem_addr", addr);
    emit_line(DMS "mem_tmp set value {}");
    emit_line(EIS ELVM_MEM_ADDR "matches ..8388607 run " DMS "mem_tmp " SFS "mem.l");
    emit_line(EUS ELVM_MEM_ADDR "matches ..8388607 run " DMS "mem_tmp " SFS "mem.r");
    emit_line(EUS ELVM_MEM_ADDR "matches ..8388607 run " SPR ELVM_MEM_ADDR "8388608");
    for (int i = 1; i < 23; i++) {
      emit_line(EIS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp " SFS "mem_tmp.l", (1 << (23 - i)) - 1);
      emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp " SFS "mem_tmp.r", (1 << (23 - i)) - 1);
      emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " SPR ELVM_MEM_ADDR "%d", (1 << (23 - i)) - 1, 1 << (23 - i));
    }
    emit_line(EIS ELVM_MEM_ADDR "matches 0 " SRSC "ELVM %s run " DGS "mem_tmp.l", dst_reg);
    emit_line(EUS ELVM_MEM_ADDR "matches 0 " SRSC "ELVM %s run " DGS "mem_tmp.r", dst_reg);
  }
}

static void define_chr_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  if (range == 256)
    mcf_emit_function_header("elvm:chr");
  else
    mcf_emit_function_header(format("elvm:chr_%d_%d", min, max));
  if (range == 2) {
    char ch[3];
    mcf_char_to_string((char)min, ch);
    emit_line(EIS ELVM_PARAM "matches %d run " DMS "chr set value \"%s\"", min, ch);
    mcf_char_to_string((char)mid, ch);
    emit_line(EIS ELVM_PARAM "matches %d run " DMS "chr set value \"%s\"", mid, ch);
  } else {
    if (mid <= 32)
      emit_line(EIS ELVM_PARAM "matches %d..%d run " DMS "chr set value \" \"", min, mid-1);
    else
      emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:chr_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:chr_%d_%d", mid, max-1, mid, max);
    if (mid > 32)
      define_chr_function(min, mid);
    define_chr_function(mid, max);
  }
}

char json_string[11156];

static void get_json_string(int len, char* out) {
  int i = 0;
  out[i++] = '[';
  for (int j = 0; j < len; j++) {
    const char* val = format("%s{\"storage\":\"elvm:elvm\",\"nbt\":\"stdout[%d]\"}", j == 0 ? "" : ",", j);
    for (; *val; val++)
      out[i++] = *val;
  }
  out[i++] = ']';
  out[i] = '\0';
}

static void define_flush_function_recursive(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:flush_%d_%d", min, max));
  if (min == 0 && range == 4) {
    for (int i = 1; i < 4; i++) {
      get_json_string(i, json_string);
      emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", i, json_string);
    }
  } else if (range == 2) {
    get_json_string(min, json_string);
    emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", min, json_string);
    get_json_string(mid, json_string);
    emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", mid, json_string);
  } else {
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:flush_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:flush_%d_%d", mid, max-1, mid, max);
    define_flush_function_recursive(min, mid);
    define_flush_function_recursive(mid, max);
  }
}

static void define_flush256() {
  mcf_emit_function_header("elvm:flush256");
  emit_line(DRS "stdout[0]");
  emit_line(SPR ELVM_PARAM "1");
  emit_line(EIS ELVM_PARAM "matches -256.. run " F "elvm:flush256");
}

static void define_flush_function() {
  mcf_emit_function_header("elvm:flush");
  emit_line(E SRSC ELVM_PARAM "run " DGS "stdout");
  emit_line(F "elvm:flush_0_256");
  emit_line(EIS ELVM_PARAM "matches 256.. run " SPS ELVM_PARAM "-1");
  emit_line(EIS ELVM_PARAM "matches -1 run " F "elvm:flush256");
  emit_line(EIS ELVM_PARAM "matches ..-1 run " F "elvm:flush");
  emit_line(DMS "stdout set value []");
  define_flush256();
  define_flush_function_recursive(0, 256);
}


static void mcf_emit_test(Inst* inst,
                          int num_commands_when_false, const char** cmds_when_false,
                          int num_commands_when_true, const char** cmds_when_true,
                          bool true_first) {
  bool inverted = 0;
  Op op = normalize_cond(inst->op, 0);
  if (op == JNE || op == JLT || op == JGT) {
    inverted = 1;
    op = normalize_cond(op, 1);
  }

  const char* if_ = inverted ? "unless" : "if";
  const char* unless = inverted ? "if" : "unless";
  const char* false_test;
  const char* true_test;
  if (inst->src.type == IMM) {
    const char* left_dots = op == JLE ? ".." : "";
    const char* right_dots = op == JGE ? ".." : "";
    false_test = format(E "%s score ELVM %s matches %s%d%s run ",
                        unless, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
    true_test = format(E "%s score ELVM %s matches %s%d%s run ",
                        if_, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
  } else {
    const char* op_str = op == JEQ ? "=" : op == JLE ? "<=" : ">=";
    false_test = format(E "%s score ELVM %s %s ELVM %s run ",
                        unless, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
    true_test = format(E "%s score ELVM %s %s ELVM %s run ",
                        if_, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
  }
  if (true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
  for (int i = 0; i < num_commands_when_false; i++)
    emit_line("%s%s", false_test, cmds_when_false[i]);
  if (!true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
}

bool was_jump = 1;

static void mcf_emit_inst(Inst* inst) {
  was_jump = 0;
  switch (inst->op) {
    case MOV: {
      mcf_emit_set_reg(reg_names[inst->dst.reg], &inst->src);
      break;
    }

    case ADD: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPR "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPA "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s += ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case SUB: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPA "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPR "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s -= ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case LOAD: {
      mcf_emit_mem_table_load(reg_names[inst->dst.reg], &inst->src);
      break;
    }

    case STORE: {
      mcf_emit_mem_table_store(&inst->src, &inst->dst);
      break;
    }

    case EXIT: {
      was_jump = 1;
      emit_line(SPS ELVM_PC "-1");
      break;
    }

    case PUTC: {
      if (inst->src.type == IMM) {
        int val = inst->src.imm;
        if (val == '\n') {
          used_flush_function = 1;
          emit_line(F "elvm:flush");
        } else {
          char ch[3];
          mcf_char_to_string((char)val, ch);
          emit_line(DMS "stdout append value \"%s\"", ch);
        }
      } else {
        used_chr_function = 1;
        used_flush_function = 1;
        mcf_emit_set_reg("elvm_param", &inst->src);
        emit_line(EUS ELVM_PARAM "matches 10 run " F "elvm:chr");
        emit_line(EUS ELVM_PARAM "matches 10 run " DMS "stdout append from storage elvm:elvm chr");
        emit_line(EIS ELVM_PARAM "matches 10 run " F "elvm:flush");
      }
      break;
    }

    case GETC: {
      /* TODO: implement */
      break;
    }

    case DUMP: {
      break;
    }

    case EQ:
    case NE:
    case LT:
    case LE:
    case GT:
    case GE: {
      const char* cmd_when_false = SPS ELVM_TMP "0";
      const char* cmd_when_true = SPS ELVM_TMP "1";
      mcf_emit_test(inst, 1, &cmd_when_false, 1, &cmd_when_true, 0);
      emit_line(SPO "ELVM %s = ELVM elvm_tmp", reg_names[inst->dst.reg]);
      break;
    }

    case JMP: {
      was_jump = 1;
      mcf_emit_set_reg("elvm_pc", &inst->jmp);
      if (inst->jmp.type == IMM)
        emit_line(F "elvm:func_%d", inst->jmp.imm);
      break;
    }

    case JEQ:
    case JNE:
    case JLT:
    case JLE:
    case JGT:
    case JGE: {
      was_jump = 1;
      const char* cmd_when_false = format(SPS ELVM_PC "%d", inst->pc + 1);
      const char* cmd_when_true;
      if (inst->jmp.type == IMM)
        cmd_when_true = format(SPS ELVM_PC "%d", inst->jmp.imm);
      else
        cmd_when_true = format(SPO ELVM_PC "= ELVM %s", reg_names[inst->jmp.reg]);
      mcf_emit_test(inst, 1, &cmd_when_false, 1, &cmd_when_true, 0);
      emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", inst->pc + 1, inst->pc + 1);
      if (inst->jmp.type == IMM)
        emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", inst->jmp.imm, inst->jmp.imm);
      break;
    }

    default:
      error("oops");
  }
}

typedef union Node_ {
  struct {
    union Node_* left;
    union Node_* right;
  };
  int val;
} Node;

static void set_in_tree(Node* tree, int depth, int addr, int value) {
  if (depth == 0) {
    tree->val = value;
  } else {
    if (addr & (1 << (depth - 1))) {
      if (!tree->right)
        tree->right = (Node*) calloc(1, sizeof(*tree->right));
      set_in_tree(tree->right, depth - 1, addr, value);
    } else {
      if (!tree->left)
        tree->left = (Node*) calloc(1, sizeof(*tree->left));
      set_in_tree(tree->left, depth - 1, addr, value);
    }
  }
}

static char* tree_to_nbt(Node* tree, int depth) {
  if (depth == 0) {
    return format("%d", tree->val);
  }
  if (tree->left) {
    if (tree->right) {
      return format("{\"l\":%s,\"r\":%s}", tree_to_nbt(tree->left, depth - 1), tree_to_nbt(tree->right, depth - 1));
    } else {
      return format("{\"l\":%s}", tree_to_nbt(tree->left, depth - 1));
    }
  } else {
    if (tree->right) {
      return format("{\"r\":%s}", tree_to_nbt(tree->right, depth - 1));
    } else {
      return strdup("{}");
    }
  }
}

static void free_tree(Node* tree, int depth) {
  if (depth > 0) {
    if (tree->left)
      free_tree(tree->left, depth - 1);
    if (tree->right)
      free_tree(tree->right, depth - 1);
  }
  free(tree);
}

static void emit_memory_initialization(Data* data) {
  Node* root = (Node*) calloc(1, sizeof(*root));

  for (int mp = 0; data; data = data->next, mp++) {
    if (data->v) {
      set_in_tree(root, 24, mp, data->v);
    }
  }

  emit_line(DMS "mem set value %s", tree_to_nbt(root, 24));

  free_tree(root, 24);
}

static void emit_main_function(Data* data) {

  mcf_emit_function_header("elvm:main");
  for (int i = 0; i < 7; i++) {
    emit_line(SOA "%s dummy", reg_names[i]);
    emit_line(SPS "ELVM %s 0", reg_names[i]);
  }

  emit_line(SOA "elvm_tmp dummy");

  emit_memory_initialization(data);

  emit_line(SOA "elvm_mem_addr dummy");
  emit_line(SOA "elvm_param dummy");
  emit_line(SOA "elvm_mem_res dummy");

  emit_line(SOA "elvm_uint_max dummy");
  emit_line(SPS "ELVM elvm_uint_max %d", UINT_MAX + 1);
  emit_line(SOA "elvm_two dummy");
  emit_line(SPS "ELVM elvm_two 2");

  emit_line(DMS "stdout set value []");

  emit_line(EIS ELVM_PC "matches 0.. run " F "elvm:loop");
}

static void emit_loop_function(int pc_count) {
  mcf_emit_function_header("elvm:loop");
  emit_line(F "elvm:func_0_%d", pc_count);
  emit_line(EIS ELVM_PC "matches 0.. run " F "elvm:loop");
}

static void emit_pc_search_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:func_%d_%d", min, max));
  if (range < 4) {
    for (int i = 0; i < range; i++) {
      emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", min + i, min + i);
    }
  } else {
    emit_line(EIS ELVM_PC "matches %d..%d run " F "elvm:func_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PC "matches %d..%d run " F "elvm:func_%d_%d", mid, max-1, mid, max);
    emit_pc_search_function(min, mid);
    emit_pc_search_function(mid, max);
  }
}

static void define_utility_functions() {
  if (used_chr_function)
    define_chr_function(0, 256);
  if (used_flush_function)
    define_flush_function();
}

void target_mcfunction(Module* module) {
  reg_names = MCFUNCTION_REG_NAMES;

  int pc = -1;
  for (Inst* inst = module->text; inst; inst = inst->next) {
    if (inst->pc != pc) {
      pc = inst->pc;
      if (!was_jump) {
        emit_line(SPA ELVM_PC "1");
        emit_line(F "elvm:func_%d", inst->pc);
      }
      mcf_emit_function_header(format("elvm:func_%d", pc));
    }
    mcf_emit_inst(inst);
  }

  emit_pc_search_function(0, pc+1);
  emit_main_function(module->data);
  emit_loop_function(pc+1);
  define_utility_functions();

}
