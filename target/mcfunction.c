
#include <ir/ir.h>
#include <target/util.h>
#include <stdlib.h>
#include <string.h>

#define SOA "scoreboard objectives add "
#define SOR "scoreboard objectives remove "
#define SPG "scoreboard players get "
#define SPS "scoreboard players set "
#define SPA "scoreboard players add "
#define SPR "scoreboard players remove "
#define SPO "scoreboard players operation "
#define DMS "data modify storage elvm:elvm "
#define DGS "data get storage elvm:elvm "
#define DRS "data remove storage elvm:elvm "
#define DMES "data merge storage elvm:elvm "
#define EIS "execute if score "
#define EUS "execute unless score "
#define E "execute "
#define SRST "store result storage elvm:elvm "
#define SRSC "store result score "
#define SFS "set from storage elvm:elvm "
#define F "function "

#define ELVM_PC "ELVM elvm_pc "
#define ELVM_MEM_ADDR "ELVM elvm_mem_addr "
#define ELVM_TMP "ELVM elvm_tmp "
#define ELVM_PARAM "ELVM elvm_param "

#define CACHE_SIZE 32
#define CACHE_DEPTH 5
#define CACHE_COUNT 2

static const char* MCFUNCTION_REG_NAMES[7] = { "elvm_a", "elvm_b", "elvm_c", "elvm_d", "elvm_bp", "elvm_sp", "elvm_pc" };

static bool used_chr_function = 0;
static bool used_flush_function = 0;
static bool used_cache_function = 0;

static void mcf_char_to_string(char c, char* out) {
  if ((c >= 0 && c < 32) || c == 127)
    c = ' ';

  if (c == '"' || c == '\\') {
    out[0] = '\\';
    out[1] = c;
    out[2] = '\0';
  } else if (!(c & 0x80)) {
    out[0] = c;
    out[1] = '\0';
  } else {
    out[0] = (char)0xc0 | (char)(((unsigned)c & 0xff) >> 6);
    out[1] = (char)0x80 | (c & (char)0x3f);
    out[2] = '\0';
  }
}

static void mcf_static_read_mem_loc(int loc, const char* mem_name, char* res, int mem_size) {
  strcpy(res, mem_name);
  for (int i = 0; i < mem_size; i++) {
    if (loc & (1 << (mem_size - 1 - i)))
      strcat(res, ".r");
    else
      strcat(res, ".l");
  }
}

static void mcf_static_write_mem_loc(int loc, const char* mem_name, const char* value, char* res, int mem_size) {
  strcpy(res, "{\"");
  strcat(res, mem_name);
  strcat(res, "\":");
  for (int i = 0; i < mem_size; i++) {
    if (loc & (1 << (mem_size - 1 - i)))
      strcat(res, "{\"r\":");
    else
      strcat(res, "{\"l\":");
  }
  strcat(res, value);
  for (int i = 0; i <= mem_size; i++)
    strcat(res, "}");
}

static void mcf_emit_function_header(const char *name) {
  emit_line("========= %s.mcfunction =========", name);
  emit_line("# Generated by ELVM");
}

static void mcf_emit_set_reg(const char *reg, Value *value) {
  if (value->type == REG)
    emit_line(SPO "ELVM %s = ELVM %s", reg, reg_names[value->reg]);
  else if (value->type == IMM)
    emit_line(SPS "ELVM %s %d", reg, value->imm);
  else
    error("invalid value");
}

static void mcf_emit_mem_table_store(Value *addr, Value *value) {
  if (addr->type == IMM) {
    char write_mem_loc[164];
    if (value->type == IMM) {
      mcf_static_write_mem_loc(addr->imm, "mem", format("%d", value->imm), write_mem_loc, 24);
      emit_line(DMES "%s", write_mem_loc);
      for (int i = 0; i < CACHE_COUNT; i++) {
        mcf_static_write_mem_loc(addr->imm, format("cache%d", i), format("%d", value->imm), write_mem_loc, CACHE_DEPTH);
        emit_line(EIS "ELVM elvm_cache%d_lo matches %d if score ELVM elvm_cache%d_hi matches %d run " DMES "%s",
                  i, addr->imm & ~(CACHE_SIZE - 1), i, (addr->imm & ~(CACHE_SIZE - 1)) + CACHE_SIZE, write_mem_loc);
      }
    } else {
      mcf_static_write_mem_loc(addr->imm, "mem", "0", write_mem_loc, 24);
      emit_line(DMES "%s", write_mem_loc);
      mcf_static_read_mem_loc(addr->imm, "mem", write_mem_loc, 24);
      emit_line(E SRST "%s int 1 run " SPG "ELVM %s",
                write_mem_loc, reg_names[value->reg]);
      for (int i = 0; i < CACHE_COUNT; i++) {
        mcf_static_write_mem_loc(addr->imm, format("cache%d", i), "0", write_mem_loc, CACHE_DEPTH);
        emit_line(EIS "ELVM elvm_cache%d_lo matches %d if score ELVM elvm_cache%d_hi matches %d run " DMES "%s",
                  i, addr->imm & ~(CACHE_SIZE - 1), i, (addr->imm & ~(CACHE_SIZE - 1)) + CACHE_SIZE, write_mem_loc);
        mcf_static_read_mem_loc(addr->imm, format("cache%d", i), write_mem_loc, CACHE_DEPTH);
        emit_line(EIS "ELVM elvm_cache%d_lo matches %d if score ELVM elvm_cache%d_hi matches %d " SRST "%s int 1 run " SPG "ELVM %s",
                  i, addr->imm & ~(CACHE_SIZE - 1), i, (addr->imm & ~(CACHE_SIZE - 1)) + CACHE_SIZE, write_mem_loc, reg_names[value->reg]);
      }
    }
  } else {
    used_cache_function = 1;
    mcf_emit_set_reg("elvm_mem_addr", addr);
    mcf_emit_set_reg("elvm_param", value);
    emit_line(SPS "ELVM elvm_success 0");
    emit_line(EIS ELVM_MEM_ADDR ">= ELVM elvm_cache0_lo if score " ELVM_MEM_ADDR "< ELVM elvm_cache0_hi run " F "elvm:storecached0");
    for (int i = 1; i < CACHE_COUNT; i++)
      emit_line(EIS "ELVM elvm_success matches 0 if score " ELVM_MEM_ADDR ">= ELVM elvm_cache%d_lo if score " ELVM_MEM_ADDR "< ELVM elvm_cache%d_hi run " F "elvm:storecached%d", i, i, i);
    emit_line(EIS "ELVM elvm_success matches 0 run " F "elvm:recache");
    emit_line(EIS "ELVM elvm_success matches 0 run " F "elvm:storecached0");
  }
}

static void mcf_emit_mem_table_load(const char* dst_reg, Value* addr) {
  if (addr->type == IMM) {
    char read_mem_loc[52];
    mcf_static_read_mem_loc(addr->imm, "mem", read_mem_loc, 24);
    emit_line(E SRSC "ELVM %s run " DGS "%s", dst_reg, read_mem_loc);
    for (int i = 0; i < CACHE_COUNT; i++) {
      mcf_static_read_mem_loc(addr->imm, format("cache%d", i), read_mem_loc, CACHE_DEPTH);
      emit_line(EIS "ELVM elvm_cache%d_lo matches %d if score ELVM elvm_cache%d_hi matches %d " SRSC "ELVM %s run " DGS "%s",
                i, addr->imm & ~(CACHE_SIZE - 1), i, (addr->imm & ~(CACHE_SIZE - 1)) + CACHE_SIZE, dst_reg, read_mem_loc);
    }
  } else {
    used_cache_function = 1;
    mcf_emit_set_reg("elvm_mem_addr", addr);
    emit_line(SPS "ELVM elvm_success 0");
    emit_line(EIS ELVM_MEM_ADDR ">= ELVM elvm_cache0_lo if score " ELVM_MEM_ADDR "< ELVM elvm_cache0_hi run " F "elvm:loadcached0");
    for (int i = 1; i < CACHE_COUNT; i++)
      emit_line(EIS "ELVM elvm_success matches 0 if score " ELVM_MEM_ADDR ">= ELVM elvm_cache%d_lo if score " ELVM_MEM_ADDR "< ELVM elvm_cache%d_hi run " F "elvm:loadcached%d", i, i, i);
    emit_line(EIS "ELVM elvm_success matches 0 run " F "elvm:recache");
    emit_line(EIS "ELVM elvm_success matches 0 run " F "elvm:loadcached0");
    emit_line(SPO "ELVM %s = ELVM elvm_mem_res", dst_reg);
  }
}

static void define_storecached_function(int cache_id) {
  mcf_emit_function_header(format("elvm:storecached%d", cache_id));
  emit_line(SPS "ELVM elvm_success 1");
  emit_line(SPO ELVM_MEM_ADDR "-= ELVM elvm_cache%d_lo", cache_id);
  char mem_val[3 * (CACHE_DEPTH - 1)];
  strcpy(mem_val, "{}");
  for (int i = 1; i < CACHE_DEPTH - 1; i++)
    strcat(mem_val, ",{}");
  emit_line(DMS "mem_tmp set value [%s]", mem_val);
  emit_line(SPO ELVM_TMP "= ELVM elvm_mem_addr");
  emit_line(EIS ELVM_TMP "matches ..%d run " DMS "mem_tmp[0] " SFS "cache%d.l", CACHE_SIZE / 2 - 1, cache_id);
  emit_line(EUS ELVM_TMP "matches ..%d run " DMS "mem_tmp[0] " SFS "cache%d.r", CACHE_SIZE / 2 - 1, cache_id);
  emit_line(EUS ELVM_TMP "matches ..%d run " SPR ELVM_TMP "%d", CACHE_SIZE / 2 - 1, CACHE_SIZE / 2);
  for (int i = 1; i < CACHE_DEPTH - 1; i++) {
    emit_line(EIS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].l",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].r",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " SPR ELVM_TMP "%d",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, 1 << (CACHE_DEPTH - 1 - i));
  }
  emit_line(EIS ELVM_TMP "matches 0 " SRST "mem_tmp[%d].l int 1 run " SPG ELVM_PARAM, CACHE_DEPTH - 2);
  emit_line(EUS ELVM_TMP "matches 0 " SRST "mem_tmp[%d].r int 1 run " SPG ELVM_PARAM, CACHE_DEPTH - 2);
  for (int i = CACHE_DEPTH - 2; i >= 1; i--) {
    emit_line(SPO ELVM_MEM_ADDR "/= ELVM elvm_two");
    emit_line(SPO ELVM_TMP "= ELVM elvm_mem_addr");
    emit_line(SPO ELVM_TMP "%%= ELVM elvm_two");
    emit_line(EIS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].l " SFS "mem_tmp[%d]", i - 1, i);
    emit_line(EUS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].r " SFS "mem_tmp[%d]", i - 1, i);
  }
  emit_line(SPO ELVM_MEM_ADDR "/= ELVM elvm_two");
  emit_line(SPO ELVM_MEM_ADDR "%%= ELVM elvm_two");
  emit_line(EIS ELVM_MEM_ADDR "matches 0 run " DMS "cache%d.l " SFS "mem_tmp[0]", cache_id);
  emit_line(EUS ELVM_MEM_ADDR "matches 0 run " DMS "cache%d.r " SFS "mem_tmp[0]", cache_id);
}

static void define_loadcached_function(int cache_id) {
  mcf_emit_function_header(format("elvm:loadcached%d", cache_id));
  emit_line(SPS "ELVM elvm_success 1");
  emit_line(SPO ELVM_MEM_ADDR "-= ELVM elvm_cache%d_lo", cache_id);
  char mem_val[3 * (CACHE_DEPTH - 1)];
  strcpy(mem_val, "{}");
  for (int i = 1; i < CACHE_DEPTH - 1; i++)
    strcat(mem_val, ",{}");
  emit_line(DMS "mem_tmp set value [%s]", mem_val);
  emit_line(EIS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[0] " SFS "cache%d.l", CACHE_SIZE / 2 - 1, cache_id);
  emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[0] " SFS "cache%d.r", CACHE_SIZE / 2 - 1, cache_id);
  emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " SPR ELVM_MEM_ADDR "%d", CACHE_SIZE / 2 - 1, CACHE_SIZE / 2);
  for (int i = 1; i < CACHE_DEPTH - 1; i++) {
    emit_line(EIS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].l",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].r",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_MEM_ADDR "matches ..%d run " SPR ELVM_MEM_ADDR "%d",
              (1 << (CACHE_DEPTH - 1 - i)) - 1, 1 << (CACHE_DEPTH - 1 - i));
  }
  emit_line(EIS ELVM_MEM_ADDR "matches 0 " SRSC "ELVM elvm_mem_res run " DGS "mem_tmp[%d].l", CACHE_DEPTH - 2);
  emit_line(EUS ELVM_MEM_ADDR "matches 0 " SRSC "ELVM elvm_mem_res run " DGS "mem_tmp[%d].r", CACHE_DEPTH - 2);
}

static void define_recache_function() {
  mcf_emit_function_header(format("elvm:recache"));
  char mem_val[3 * (23 - CACHE_DEPTH)];
  strcpy(mem_val, "{}");
  for (int i = 1; i < 23 - CACHE_DEPTH; i++)
    strcat(mem_val, ",{}");
  emit_line(DMS "mem_tmp set value [%s]", mem_val);
  emit_line(SPO ELVM_TMP "= ELVM elvm_cache%d_lo", CACHE_COUNT - 1);
  emit_line(EIS ELVM_TMP "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.l");
  emit_line(EUS ELVM_TMP "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.r");
  emit_line(EUS ELVM_TMP "matches ..8388607 run " SPR ELVM_TMP "8388608");
  for (int i = 1; i < 23 - CACHE_DEPTH; i++) {
    emit_line(EIS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].l", (1 << (23 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].r", (1 << (23 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " SPR ELVM_TMP "%d", (1 << (23 - i)) - 1, 1 << (23 - i));
  }
  emit_line(EIS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d].l " SFS "cache%d",
            CACHE_SIZE - 1, 22 - CACHE_DEPTH, CACHE_COUNT - 1);
  emit_line(EUS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d].r " SFS "cache%d",
            CACHE_SIZE - 1, 22 - CACHE_DEPTH, CACHE_COUNT - 1);
  for (int i = 22 - CACHE_DEPTH; i >= 1; i--) {
    emit_line(SPO "ELVM elvm_cache%d_lo /= ELVM %s", CACHE_COUNT - 1, i == 22 - CACHE_DEPTH ? "elvm_2cache_size" : "elvm_two");
    emit_line(SPO ELVM_TMP "= ELVM elvm_cache%d_lo", CACHE_COUNT - 1);
    emit_line(SPO ELVM_TMP "%%= ELVM elvm_two");
    emit_line(EIS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].l " SFS "mem_tmp[%d]", i - 1, i);
    emit_line(EUS ELVM_TMP "matches 0 run " DMS "mem_tmp[%d].r " SFS "mem_tmp[%d]", i - 1, i);
  }
  emit_line(SPO "ELVM elvm_cache%d_lo /= ELVM elvm_two", CACHE_COUNT - 1);
  emit_line(SPO "ELVM elvm_cache%d_lo %%= ELVM elvm_two", CACHE_COUNT - 1);
  emit_line(EIS "ELVM elvm_cache%d_lo matches 0 run " DMS "mem.l " SFS "mem_tmp[0]", CACHE_COUNT - 1);
  emit_line(EUS "ELVM elvm_cache%d_lo matches 0 run " DMS "mem.r " SFS "mem_tmp[0]", CACHE_COUNT - 1);

  for (int i = CACHE_COUNT - 1; i > 0; i--) {
    emit_line(DMS "cache%d " SFS "cache%d", i, i - 1);
    emit_line(SPO "ELVM elvm_cache%d_lo = ELVM elvm_cache%d_lo", i, i - 1);
    emit_line(SPO "ELVM elvm_cache%d_hi = ELVM elvm_cache%d_hi", i, i - 1);
  }
  emit_line(SPO "ELVM elvm_cache0_lo = ELVM elvm_mem_addr");
  emit_line(SPO "ELVM elvm_cache0_lo /= ELVM elvm_cache_size");
  emit_line(SPO "ELVM elvm_cache0_lo *= ELVM elvm_cache_size");
  emit_line(SPO "ELVM elvm_cache0_hi = ELVM elvm_cache0_lo");
  emit_line(SPA "ELVM elvm_cache0_hi %d", CACHE_SIZE);

  emit_line(DMS "cache0 set value {}");
  emit_line(SPO ELVM_TMP "= ELVM elvm_mem_addr");
  emit_line(DMS "mem_tmp set value [%s]", mem_val);
  emit_line(EIS ELVM_TMP "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.l");
  emit_line(EUS ELVM_TMP "matches ..8388607 run " DMS "mem_tmp[0] " SFS "mem.r");
  emit_line(EUS ELVM_TMP "matches ..8388607 run " SPR ELVM_TMP "8388608");
  for (int i = 1; i < 23 - CACHE_DEPTH; i++) {
    emit_line(EIS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].l", (1 << (23 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " DMS "mem_tmp[%d] " SFS "mem_tmp[%d].r", (1 << (23 - i)) - 1, i, i - 1);
    emit_line(EUS ELVM_TMP "matches ..%d run " SPR ELVM_TMP "%d",
              (1 << (23 - i)) - 1, 1 << (23 - i));
  }
  emit_line(EIS ELVM_TMP "matches ..%d run " DMS "cache0 " SFS "mem_tmp[%d].l", CACHE_SIZE - 1, 22 - CACHE_DEPTH);
  emit_line(EUS ELVM_TMP "matches ..%d run " DMS "cache0 " SFS "mem_tmp[%d].r", CACHE_SIZE - 1, 22 - CACHE_DEPTH);
}

static void define_chr_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  if (range == 256)
    mcf_emit_function_header("elvm:chr");
  else
    mcf_emit_function_header(format("elvm:chr_%d_%d", min, max));
  if (range == 2) {
    char ch[3];
    mcf_char_to_string((char)min, ch);
    emit_line(EIS ELVM_PARAM "matches %d run " DMS "chr set value \"%s\"", min, ch);
    mcf_char_to_string((char)mid, ch);
    emit_line(EIS ELVM_PARAM "matches %d run " DMS "chr set value \"%s\"", mid, ch);
  } else {
    if (mid <= 32)
      emit_line(EIS ELVM_PARAM "matches %d..%d run " DMS "chr set value \" \"", min, mid-1);
    else
      emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:chr_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:chr_%d_%d", mid, max-1, mid, max);
    if (mid > 32)
      define_chr_function(min, mid);
    define_chr_function(mid, max);
  }
}

char json_string[11156];

static void get_json_string(int len, char* out) {
  int i = 0;
  out[i++] = '[';
  for (int j = 0; j < len; j++) {
    const char* val = format("%s{\"storage\":\"elvm:elvm\",\"nbt\":\"stdout[%d]\"}", j == 0 ? "" : ",", j);
    for (; *val; val++)
      out[i++] = *val;
  }
  out[i++] = ']';
  out[i] = '\0';
}

static void define_flush_function_recursive(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:flush_%d_%d", min, max));
  if (min == 0 && range == 4) {
    for (int i = 1; i < 4; i++) {
      get_json_string(i, json_string);
      emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", i, json_string);
    }
  } else if (range == 2) {
    get_json_string(min, json_string);
    emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", min, json_string);
    get_json_string(mid, json_string);
    emit_line(EIS ELVM_PARAM "matches %d run tellraw @a %s", mid, json_string);
  } else {
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:flush_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PARAM "matches %d..%d run " F "elvm:flush_%d_%d", mid, max-1, mid, max);
    define_flush_function_recursive(min, mid);
    define_flush_function_recursive(mid, max);
  }
}

static void define_flush256() {
  mcf_emit_function_header("elvm:flush256");
  emit_line(DRS "stdout[0]");
  emit_line(SPR ELVM_PARAM "1");
  emit_line(EIS ELVM_PARAM "matches -256.. run " F "elvm:flush256");
}

static void define_flush_function() {
  mcf_emit_function_header("elvm:flush");
  emit_line(E SRSC ELVM_PARAM "run " DGS "stdout");
  emit_line(F "elvm:flush_0_256");
  emit_line(EIS ELVM_PARAM "matches 256.. run " SPS ELVM_PARAM "-1");
  emit_line(EIS ELVM_PARAM "matches -1 run " F "elvm:flush256");
  emit_line(EIS ELVM_PARAM "matches ..-1 run " F "elvm:flush");
  emit_line(DMS "stdout set value []");
  define_flush256();
  define_flush_function_recursive(0, 256);
}


static void mcf_emit_test(Inst* inst,
                          int num_commands_when_false, const char** cmds_when_false,
                          int num_commands_when_true, const char** cmds_when_true,
                          bool true_first) {
  bool inverted = 0;
  Op op = normalize_cond(inst->op, 0);
  if (op == JNE || op == JLT || op == JGT) {
    inverted = 1;
    op = normalize_cond(op, 1);
  }

  const char* if_ = inverted ? "unless" : "if";
  const char* unless = inverted ? "if" : "unless";
  const char* false_test;
  const char* true_test;
  if (inst->src.type == IMM) {
    const char* left_dots = op == JLE ? ".." : "";
    const char* right_dots = op == JGE ? ".." : "";
    false_test = format(E "%s score ELVM %s matches %s%d%s run ",
                        unless, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
    true_test = format(E "%s score ELVM %s matches %s%d%s run ",
                        if_, reg_names[inst->dst.reg], left_dots, inst->src.imm, right_dots);
  } else {
    const char* op_str = op == JEQ ? "=" : op == JLE ? "<=" : ">=";
    false_test = format(E "%s score ELVM %s %s ELVM %s run ",
                        unless, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
    true_test = format(E "%s score ELVM %s %s ELVM %s run ",
                        if_, reg_names[inst->dst.reg], op_str, reg_names[inst->src.reg]);
  }
  if (true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
  for (int i = 0; i < num_commands_when_false; i++)
    emit_line("%s%s", false_test, cmds_when_false[i]);
  if (!true_first) {
    for (int i = 0; i < num_commands_when_true; i++)
      emit_line("%s%s", true_test, cmds_when_true[i]);
  }
}

bool was_jump = 1;
int* adj_pcs;

static void mcf_emit_inst(Inst* inst) {
  was_jump = 0;
  switch (inst->op) {
    case MOV: {
      mcf_emit_set_reg(reg_names[inst->dst.reg], &inst->src);
      break;
    }

    case ADD: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPR "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPA "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s += ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case SUB: {
      const char* dst = reg_names[inst->dst.reg];
      if (inst->src.type == IMM) {
        if (inst->src.imm & UINT_MAX) {
          if (inst->src.imm < 0)
            emit_line(SPA "ELVM %s %d", dst, -inst->src.imm);
          else
            emit_line(SPR "ELVM %s %d", dst, inst->src.imm);
        }
      } else {
        emit_line(SPO "ELVM %s -= ELVM %s", dst, reg_names[inst->src.reg]);
      }
      emit_line(SPO "ELVM %s %%= ELVM elvm_uint_max", dst);
      break;
    }

    case LOAD: {
      mcf_emit_mem_table_load(reg_names[inst->dst.reg], &inst->src);
      break;
    }

    case STORE: {
      mcf_emit_mem_table_store(&inst->src, &inst->dst);
      break;
    }

    case EXIT: {
      was_jump = 1;
      emit_line(SPS ELVM_PC "-1");
      break;
    }

    case PUTC: {
      if (inst->src.type == IMM) {
        int val = inst->src.imm;
        if (val == '\n') {
          used_flush_function = 1;
          emit_line(F "elvm:flush");
        } else {
          char ch[3];
          mcf_char_to_string((char)val, ch);
          emit_line(DMS "stdout append value \"%s\"", ch);
        }
      } else {
        used_chr_function = 1;
        used_flush_function = 1;
        mcf_emit_set_reg("elvm_param", &inst->src);
        emit_line(EUS ELVM_PARAM "matches 10 run " F "elvm:chr");
        emit_line(EUS ELVM_PARAM "matches 10 run " DMS "stdout append from storage elvm:elvm chr");
        emit_line(EIS ELVM_PARAM "matches 10 run " F "elvm:flush");
      }
      break;
    }

    case GETC: {
      was_jump = 1;
      emit_line(E SRSC ELVM_TMP "run " DGS "stdin");
      emit_line(EIS ELVM_TMP "matches 0 run schedule function elvm:func_%d 1", inst->pc);
      emit_line(EIS ELVM_TMP "matches 0 run " SOA "elvm_getc_pc dummy");
      emit_line(EIS ELVM_TMP "matches 0 run " SPS "ELVM elvm_getc_pc %d", inst->pc);
      emit_line(EIS ELVM_TMP "matches 0 run " SPS ELVM_PC "-1");
      emit_line(EUS ELVM_TMP "matches 0 run " SOR "elvm_getc_pc");
      emit_line(EUS ELVM_TMP "matches 0 " SRSC "ELVM %s run " DGS "stdin[0]", reg_names[inst->dst.reg]);
      emit_line(EUS ELVM_TMP "matches 0 run " DRS "stdin[0]");
      emit_line(EUS ELVM_TMP "matches 0 run " SPS ELVM_PC "%d", inst->jmp.imm);
      emit_line(EUS ELVM_TMP "matches 0 run " F "elvm:func_%d", inst->jmp.imm);
      break;
    }

    case DUMP: {
      break;
    }

    case EQ:
    case NE:
    case LT:
    case LE:
    case GT:
    case GE: {
      const char* cmd_when_false = SPS ELVM_TMP "0";
      const char* cmd_when_true = SPS ELVM_TMP "1";
      mcf_emit_test(inst, 1, &cmd_when_false, 1, &cmd_when_true, 0);
      emit_line(SPO "ELVM %s = ELVM elvm_tmp", reg_names[inst->dst.reg]);
      break;
    }

    case JMP: {
      was_jump = 1;
      mcf_emit_set_reg("elvm_pc", &inst->jmp);
      if (inst->jmp.type == IMM)
        emit_line(F "elvm:func_%d", inst->jmp.imm);
      break;
    }

    case JEQ:
    case JNE:
    case JLT:
    case JLE:
    case JGT:
    case JGE: {
      was_jump = 1;
      const char* cmd_when_false = format(SPS ELVM_PC "%d", adj_pcs[inst->pc]);
      const char* cmd_when_true;
      if (inst->jmp.type == IMM)
        cmd_when_true = format(SPS ELVM_PC "%d", inst->jmp.imm);
      else
        cmd_when_true = format(SPO ELVM_PC "= ELVM %s", reg_names[inst->jmp.reg]);
      mcf_emit_test(inst, 1, &cmd_when_false, 1, &cmd_when_true, 0);
      if (adj_pcs[inst->pc] != -1)
        emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", adj_pcs[inst->pc], adj_pcs[inst->pc]);
      if (inst->jmp.type == IMM)
        emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", inst->jmp.imm, inst->jmp.imm);
      break;
    }

    default:
      error("oops");
  }
}

typedef union Node_ {
  struct {
    union Node_* left;
    union Node_* right;
  };
  int val;
} Node;

static void set_in_tree(Node* tree, int depth, int addr, int value) {
  if (depth == 0) {
    tree->val = value;
  } else {
    if (addr & (1 << (depth - 1))) {
      if (!tree->right)
        tree->right = (Node*) calloc(1, sizeof(*tree->right));
      set_in_tree(tree->right, depth - 1, addr, value);
    } else {
      if (!tree->left)
        tree->left = (Node*) calloc(1, sizeof(*tree->left));
      set_in_tree(tree->left, depth - 1, addr, value);
    }
  }
}

static char* tree_to_nbt(Node* tree, int depth) {
  if (depth == 0) {
    return format("%d", tree->val);
  }
  if (tree->left) {
    if (tree->right) {
      return format("{\"l\":%s,\"r\":%s}", tree_to_nbt(tree->left, depth - 1), tree_to_nbt(tree->right, depth - 1));
    } else {
      return format("{\"l\":%s}", tree_to_nbt(tree->left, depth - 1));
    }
  } else {
    if (tree->right) {
      return format("{\"r\":%s}", tree_to_nbt(tree->right, depth - 1));
    } else {
      return strdup("{}");
    }
  }
}

static void free_tree(Node* tree, int depth) {
  if (depth > 0) {
    if (tree->left)
      free_tree(tree->left, depth - 1);
    if (tree->right)
      free_tree(tree->right, depth - 1);
  }
  free(tree);
}

static void emit_memory_initialization(Data* data) {
  Node* root = (Node*) calloc(1, sizeof(*root));

  for (int mp = 0; data; data = data->next, mp++) {
    if (data->v) {
      set_in_tree(root, 24, mp, data->v);
    }
  }

  emit_line(DMS "mem set value %s", tree_to_nbt(root, 24));

  free_tree(root, 24);
}

static void emit_main_function(Data* data, int pc_count) {

  mcf_emit_function_header("elvm:main");
  for (int i = 0; i < 7; i++) {
    emit_line(SOA "%s dummy", reg_names[i]);
    emit_line(SPS "ELVM %s 0", reg_names[i]);
  }
  emit_line(SPO ELVM_PC "= ELVM elvm_getc_pc");

  emit_line(SOA "elvm_tmp dummy");
  emit_line(SOA "elvm_success dummy");

  emit_memory_initialization(data);

  emit_line(SOA "elvm_mem_addr dummy");
  emit_line(SOA "elvm_param dummy");
  emit_line(SOA "elvm_mem_res dummy");

  emit_line(SOA "elvm_uint_max dummy");
  emit_line(SPS "ELVM elvm_uint_max %d", UINT_MAX + 1);
  emit_line(SOA "elvm_two dummy");
  emit_line(SPS "ELVM elvm_two 2");

  emit_line(DMS "stdout set value []");

  Data* cache_data = data;
  for (int i = 0; i < CACHE_COUNT; i++) {
    emit_line(SOA "elvm_cache%d_lo dummy", i);
    emit_line(SPS "ELVM elvm_cache%d_lo %d", i, i * CACHE_SIZE);
    emit_line(SOA "elvm_cache%d_hi dummy", i);
    emit_line(SPS "ELVM elvm_cache%d_hi %d", i, (i + 1) * CACHE_SIZE);

    Node* root = (Node*) calloc(1, sizeof(*root));
    for (int p = 0; cache_data && p < CACHE_SIZE; cache_data = cache_data->next, p++) {
      if (cache_data->v) {
        set_in_tree(root, CACHE_DEPTH, p, cache_data->v);
      }
    }
    emit_line(DMS "cache%d set value %s", i, tree_to_nbt(root, CACHE_DEPTH));
    free_tree(root, CACHE_DEPTH);
  }
  emit_line(SOA "elvm_cache_size dummy");
  emit_line(SPS "ELVM elvm_cache_size %d", CACHE_SIZE);
  emit_line(SOA "elvm_2cache_size dummy");
  emit_line(SPS "ELVM elvm_2cache_size %d", CACHE_SIZE * 2);

  emit_line(EIS ELVM_PC "matches 0..%d run " F "elvm:loop", pc_count - 1);
}

static void emit_loop_function(int pc_count) {
  mcf_emit_function_header("elvm:loop");
  emit_line(F "elvm:func_0_%d", pc_count);
  emit_line(EIS ELVM_PC "matches 0..%d run " F "elvm:loop", pc_count - 1);
}

static void emit_pc_search_function(int min, int max) {
  int range = max - min;
  int mid = min + range / 2;
  mcf_emit_function_header(format("elvm:func_%d_%d", min, max));
  if (range < 4) {
    for (int i = 0; i < range; i++) {
      emit_line(EIS ELVM_PC "matches %d run " F "elvm:func_%d", min + i, min + i);
    }
  } else {
    emit_line(EIS ELVM_PC "matches %d..%d run " F "elvm:func_%d_%d", min, mid-1, min, mid);
    emit_line(EIS ELVM_PC "matches %d..%d run " F "elvm:func_%d_%d", mid, max-1, mid, max);
    emit_pc_search_function(min, mid);
    emit_pc_search_function(mid, max);
  }
}

static void define_utility_functions() {
  if (used_chr_function)
    define_chr_function(0, 256);
  if (used_flush_function)
    define_flush_function();
  if (used_cache_function) {
    for (int i = 0; i < CACHE_COUNT; i++) {
      define_loadcached_function(i);
      define_storecached_function(i);
    }
    define_recache_function();
  }
}

static void preprocess_code(Inst* code) {
  if (!code)
    return;

  typedef struct Block_ {
    int pc;
    Inst* code;
    int adj_pc;
    struct Block_* next;
  } Block;

  int block_count = 1;
  Block* first_block = (Block*) malloc(sizeof(*first_block));
  first_block->pc = code->pc;
  first_block->code = code;
  first_block->adj_pc = -1;
  first_block->next = NULL;
  Block* last_block = first_block;

  Inst* prev_inst = NULL;
  for (Inst* inst = code; inst; inst = inst->next) {
    if (inst->pc != last_block->pc) {
      if (prev_inst)
        prev_inst->next = NULL;
      block_count++;
      Block* new_block = (Block*) malloc(sizeof(*new_block));
      new_block->pc = inst->pc;
      new_block->code = inst;
      new_block->adj_pc = -1;
      new_block->next = NULL;
      last_block->adj_pc = inst->pc;
      last_block->next = new_block;
      last_block = new_block;
    }
    prev_inst = inst;
  }

  for (Block* block = first_block; block; block = block->next) {
    prev_inst = NULL;
    for (Inst* inst = block->code; inst; inst = inst->next) {
      // there should be no instructions before getc (so it can schedule itself)
      if (prev_inst && inst->op == GETC) {
        block_count++;
        Block* new_block = (Block*) malloc(sizeof(*new_block));
        new_block->pc = last_block->pc + 1;
        new_block->code = inst;
        new_block->adj_pc = block->adj_pc;
        new_block->next = NULL;
        last_block->next = new_block;
        last_block = new_block;
        block->adj_pc = new_block->pc;
        prev_inst->next = NULL;
        break;
      }

      // there should be no instructions after getc or exit (they count as jump instructions for our purposes)
      if (inst->next && (inst->op == GETC || inst->op == EXIT)) {
        block_count++;
        Block* new_block = (Block*) malloc(sizeof(*new_block));
        new_block->pc = last_block->pc + 1;
        new_block->code = inst->next;
        new_block->adj_pc = block->adj_pc;
        new_block->next = NULL;
        last_block->next = new_block;
        last_block = new_block;
        inst->next = NULL;
        inst->jmp.type = IMM;
        inst->jmp.imm = new_block->pc;
        break;
      }

      prev_inst = inst;
    }
  }

  adj_pcs = (int*) malloc(block_count * sizeof(int));

  Inst* tail = NULL;
  for (Block* block = first_block; block; block = block->next) {
    for (Inst* inst = block->code; inst; inst = inst->next) {
      inst->pc = block->pc;
      if (tail)
        tail->next = inst;
      tail = inst;
    }
    adj_pcs[block->pc] = block->adj_pc;
  }

  while (first_block) {
    Block* next = first_block->next;
    free(first_block);
    first_block = next;
  }
}

void target_mcfunction(Module* module) {
  reg_names = MCFUNCTION_REG_NAMES;

  preprocess_code(module->text);

  int pc = -1;
  for (Inst* inst = module->text; inst; inst = inst->next) {
    if (inst->pc != pc) {
      if (!was_jump) {
        emit_line(SPS ELVM_PC "%d", adj_pcs[pc]);
        if (adj_pcs[pc] != -1)
          emit_line(F "elvm:func_%d", adj_pcs[pc]);
      }
      pc = inst->pc;
      mcf_emit_function_header(format("elvm:func_%d", pc));
    }
    mcf_emit_inst(inst);
  }

  emit_pc_search_function(0, pc+1);
  emit_main_function(module->data, pc+1);
  emit_loop_function(pc+1);
  define_utility_functions();

}
